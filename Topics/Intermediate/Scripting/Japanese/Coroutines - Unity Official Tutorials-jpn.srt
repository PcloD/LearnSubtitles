1
00:00:00,456 --> 00:00:02,550
コルーチンは一定間隔で実行される関数のようなものと

2
00:00:02,550 --> 00:00:04,550
考えることができます

3
00:00:05,340 --> 00:00:07,340
これら関数は  関数に対してコードの実行を返す

4
00:00:07,340 --> 00:00:10,109
特別な yield 文とともに使われます

5
00:00:10,109 --> 00:00:11,927
そして関数が処理を続行していくと

6
00:00:11,927 --> 00:00:14,999
前回の途中から実行が再開されます

7
00:00:14,999 --> 00:00:17,307
まずはコルーチンのサンプルを見てみましょう

8
00:00:17,807 --> 00:00:20,399
まずはコルーチン自体に注目してみます

9
00:00:20,399 --> 00:00:22,399
ここでは MyCoroutine という名前です

10
00:00:22,899 --> 00:00:25,066
まず目につくのが戻り値の型

11
00:00:25,066 --> 00:00:26,510
IEnumerator です

12
00:00:26,510 --> 00:00:28,510
これは関数が IEnumerator インターフェイスを実装するものであれば

13
00:00:28,510 --> 00:00:31,059
何でも返せるということを意味します

14
00:00:31,559 --> 00:00:33,559
コルーチンから返されるものは通常よりも多岐にわたりますが

15
00:00:33,559 --> 00:00:36,070
それは後々見ていくこととしましょう

16
00:00:36,070 --> 00:00:38,638
次にパラメーターとして Transform が指定され

17
00:00:38,638 --> 00:00:40,638
そして while ループが始まり

18
00:00:40,638 --> 00:00:42,775
これがオブジェクトと target の距離が 0.05 未満になるまで

19
00:00:42,775 --> 00:00:44,582
繰り返されます

20
00:00:44,582 --> 00:00:46,582
このループ内ではまずオブジェクトの位置を

21
00:00:46,582 --> 00:00:49,883
自身と target の位置の間で 線形補間（Lerp）しています

22
00:00:50,383 --> 00:00:53,575
続いて yield return null; という行があります

23
00:00:53,575 --> 00:00:56,431
ここがコルーチンの仕事を可能にしている部分です

24
00:00:56,431 --> 00:00:58,431
具体的に何が起こるかというと まず

25
00:00:58,431 --> 00:01:00,431
この行が実行されると関数が実行され

26
00:01:00,431 --> 00:01:03,259
IEnumerator に null が返されます

27
00:01:03,759 --> 00:01:05,759
そして戻り値で指定されたタイミングで

28
00:01:05,759 --> 00:01:08,076
コードの実行が再開されます

29
00:01:08,076 --> 00:01:10,076
戻り値は null なので

30
00:01:10,076 --> 00:01:12,491
コルーチンは次のアップデート後に再開されるのです

31
00:01:12,991 --> 00:01:15,600
そしてコルーチンがループの最後に再開されるため

32
00:01:15,600 --> 00:01:18,355
ループ条件が再判定されます

33
00:01:18,355 --> 00:01:20,686
transform が target に到達していない場合は

34
00:01:20,686 --> 00:01:22,686
ターゲットに近づくよう線形補間（Lerp）が行われ

35
00:01:22,686 --> 00:01:24,686
次回アップデートまで yield が実行されます

36
00:01:25,186 --> 00:01:27,186
最終的にループ条件の判定が true でなくなると

37
00:01:27,186 --> 00:01:29,186
ループ処理が終了してコルーチンが

38
00:01:29,186 --> 00:01:31,186
コンソールに「reached the target」（ターゲットに到達）と

39
00:01:31,186 --> 00:01:32,524
プリントします

40
00:01:32,524 --> 00:01:34,817
この時コルーチンは yield を実行しますが

41
00:01:34,817 --> 00:01:36,817
この場合の戻り値は WaitForSeconds クラスの

42
00:01:36,817 --> 00:01:38,720
インスタンスとなります

43
00:01:38,720 --> 00:01:40,720
そして新しいキーワードでコンストラクターが呼び出されます

44
00:01:40,720 --> 00:01:42,695
この例ではパラメーターとして 3 が

45
00:01:42,695 --> 00:01:44,292
パースされます

46
00:01:44,292 --> 00:01:46,292
そして WaitForSeconds クラスのインスタンスを

47
00:01:46,292 --> 00:01:48,292
返した後は  ご想像の通り

48
00:01:48,292 --> 00:01:50,292
指定された秒数後に

49
00:01:50,292 --> 00:01:52,292
コードが続行されます

50
00:01:52,292 --> 00:01:55,206
この場合 3 秒後に「MyCoroutine is now finished」（MyCoroutine が終了しました）

51
00:01:55,206 --> 00:01:56,789
がコンソールに表示されます

52
00:01:56,789 --> 00:01:59,220
これでコルーチンの終わりに達し

53
00:01:59,220 --> 00:02:01,220
実行は終了されます

54
00:02:01,220 --> 00:02:03,484
さて それではコルーチンの呼び出し方について見ていきましょう

55
00:02:03,817 --> 00:02:06,710
これには単純に StartCoroutine 関数を使います

56
00:02:06,710 --> 00:02:08,710
この関数はパラメーターとして コルーチンのコールまたは

57
00:02:08,710 --> 00:02:11,127
コルーチン名の文字列をひとつ取ります

58
00:02:11,627 --> 00:02:13,627
前者のコールを用いた方法が先ほど見たやり方で

59
00:02:13,627 --> 00:02:15,906
推奨の方法でもありますが

60
00:02:15,906 --> 00:02:17,906
コルーチン名の文字列で呼び出した場合は

61
00:02:17,906 --> 00:02:19,906
StopCoroutine を使って

62
00:02:19,906 --> 00:02:21,478
完全に停止させることができます

63
00:02:22,130 --> 00:02:24,240
それではコルーチンが動作するところを見てみましょう

64
00:02:24,240 --> 00:02:26,240
ここではコルーチンスクリプトをかわいいロボに

65
00:02:26,240 --> 00:02:28,734
アタッチして さらに target オブジェクトを作成しました

66
00:02:29,496 --> 00:02:31,151
シーンが実行されるとロボが target に向かって

67
00:02:31,151 --> 00:02:33,151
移動していき ロボが target に

68
00:02:33,151 --> 00:02:35,846
到達すると  コンソールにメッセージが表示されます

69
00:02:35,846 --> 00:02:38,191
そしてメッセージから 3 秒後

70
00:02:38,191 --> 00:02:40,191
2 つめのメッセージと共にコルーチンが終了します

71
00:02:40,191 --> 00:02:42,191
この例では Update を使ったり タイマーを作ったりせずに

72
00:02:42,191 --> 00:02:44,191
移動を作成していることにお気づきでしょうか?

73
00:02:44,926 --> 00:02:46,219
これはとても優れた方法で

74
00:02:46,219 --> 00:02:47,676
コードも効率的になります

75
00:02:47,676 --> 00:02:49,676
しかしコルーチンの本当の強みは

76
00:02:49,676 --> 00:02:51,676
プロパティと組み合わせた時に発揮されます

77
00:02:51,676 --> 00:02:53,676
例を見てみましょう

78
00:02:54,176 --> 00:02:56,065
このシーンでも ふたたびロボを使います

79
00:02:56,065 --> 00:02:58,065
このロボには  PropertiesAndCoroutines という

80
00:02:58,065 --> 00:02:59,816
スクリプトがアタッチされています

81
00:02:59,816 --> 00:03:02,588
またもうひとつ ClickSetPosition というスクリプトが

82
00:03:02,588 --> 00:03:04,588
背景にアタッチされています

83
00:03:04,588 --> 00:03:06,588
PropertiesAndCoroutines スクリプトは

84
00:03:06,588 --> 00:03:08,588
public Vector3 のプロパティ target を持ち

85
00:03:08,588 --> 00:03:11,140
これは target フィールドをカプセル化しています

86
00:03:11,140 --> 00:03:12,988
そして target プロパティを割り当てるときに

87
00:03:12,988 --> 00:03:14,988
set 関数を呼び出します

88
00:03:15,723 --> 00:03:17,723
これでシーン内の任意地点をクリックすると 

89
00:03:17,723 --> 00:03:19,723
ClickSetPositions スクリプトが PropertiesAndCoroutine スクリプトの

90
00:03:19,723 --> 00:03:22,764
アタッチされたオブジェクトの target をセットします

91
00:03:23,264 --> 00:03:25,403
それでは PropertiesAndCoroutines スクリプトに戻って

92
00:03:25,403 --> 00:03:27,596
target がセットされた時に 何が起こるか見てみましょう

93
00:03:27,596 --> 00:03:30,332
まず target フィールドに正しい値がセットされます

94
00:03:30,332 --> 00:03:32,332
そして移動のコルーチンを停止します

95
00:03:32,735 --> 00:03:34,735
なお  これは次の行にも関係してきますが

96
00:03:34,735 --> 00:03:36,735
StopCoroutine が動作するのはコルーチン名の

97
00:03:36,735 --> 00:03:39,904
文字列で呼び出して開始された場合だけです

98
00:03:40,404 --> 00:03:43,317
これは先ほど話した StartCoroutine を呼び出すもう一つのやり方です

99
00:03:43,317 --> 00:03:45,635
コルーチン名を文字列としてパースさせ

100
00:03:45,635 --> 00:03:47,856
続けてパラメーターを指定します

101
00:03:47,856 --> 00:03:49,856
続く Movement コルーチンの作りは

102
00:03:49,856 --> 00:03:52,077
先ほどの MyCoroutine と似ています

103
00:03:52,077 --> 00:03:54,077
キューブの位置を指定された target に近づくように

104
00:03:54,077 --> 00:03:56,077
単純に線形補間（Lerp）しています

105
00:03:57,226 --> 00:03:59,226
このスクリプトの組み方だと

106
00:03:59,226 --> 00:04:01,226
フレーム単位で値をポールする Update 関数を使うことなく

107
00:04:01,226 --> 00:04:03,226
移動するゲームオブジェクトを

108
00:04:03,226 --> 00:04:04,923
作ることができます

109
00:04:04,923 --> 00:04:06,923
値をポールする処理はコードの効率性を

110
00:04:06,923 --> 00:04:08,769
下げるものですし

111
00:04:08,769 --> 00:04:10,466
どうしても必要な時を除けば

112
00:04:10,466 --> 00:04:12,717
なるべく避けたい処理ですからね

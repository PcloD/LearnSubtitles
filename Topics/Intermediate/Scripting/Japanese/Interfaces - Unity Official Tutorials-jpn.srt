1
00:00:00,249 --> 00:00:01,952
インターフェイスとは

2
00:00:01,952 --> 00:00:03,648
機能の契約だとも考えられます

3
00:00:04,148 --> 00:00:06,148
インターフェイスを実装するクラスは

4
00:00:06,148 --> 00:00:08,690
すべてのメソッドとプロパティを保持する必要があります

5
00:00:08,690 --> 00:00:10,871
その代わりに実装するクラスはポリモーフィズム（多態性）を使用し

6
00:00:10,871 --> 00:00:13,382
他のクラスからインターフェイスのように

7
00:00:13,382 --> 00:00:15,079
扱われるようになります

8
00:00:15,079 --> 00:00:17,079
なおインターフェイスはクラスではなく

9
00:00:17,079 --> 00:00:20,462
自らのインスタンスを持てない点に注意してください

10
00:00:21,100 --> 00:00:24,075
以前取り上げたとおり継承は is-a 関係で表されます

11
00:00:24,075 --> 00:00:26,075
ひとつのクラスが別のクラスから継承するという関係ですね

12
00:00:26,075 --> 00:00:29,697
インターフェイスでは Implements （実装）関係で表されます

13
00:00:29,697 --> 00:00:32,432
ひとつのクラスがインターフェイスを実装するわけです

14
00:00:32,808 --> 00:00:36,073
インターフェイスは通常クラスの外側で宣言されます

15
00:00:36,073 --> 00:00:38,073
インターフェイスを宣言する場合には通常

16
00:00:38,073 --> 00:00:40,458
インターフェイスごとにスクリプトを作ります

17
00:00:40,458 --> 00:00:42,458
ただしこの例では同一スクリプトに 2 つのインターフェイスを

18
00:00:42,458 --> 00:00:44,458
宣言してみます

19
00:00:44,958 --> 00:00:46,958
インターフェイス名を宣言するときは

20
00:00:46,958 --> 00:00:49,837
通則的に大文字の I からはじめます

21
00:00:49,837 --> 00:00:53,088
そしてその次の文字も大文字とします

22
00:00:53,088 --> 00:00:55,687
インターフェイスは通常何らかの機能を記述するものなので

23
00:00:55,687 --> 00:00:57,687
実装クラス内には接尾詞「able」（できる）がついた

24
00:00:57,687 --> 00:01:00,901
インターフェイスが多数存在することが多いです

25
00:01:01,291 --> 00:01:03,291
なおこれは必須ではありませんし

26
00:01:03,291 --> 00:01:05,291
その用途によっては混乱を招く可能性もあるので

27
00:01:05,291 --> 00:01:07,710
気をつけてください

28
00:01:07,710 --> 00:01:09,960
さてこれで 2 つのインターフェイスを宣言できました

29
00:01:09,960 --> 00:01:12,722
IKillable と IDamageable です

30
00:01:13,222 --> 00:01:16,234
IKillable には Kill という関数があります

31
00:01:16,234 --> 00:01:19,450
この関数の戻り値の型は void でパラメーターも取りません

32
00:01:19,798 --> 00:01:22,650
この IKillable インターフェイスを実装するクラスは

33
00:01:22,650 --> 00:01:26,195
この署名に合う public な関数を持つ必要があります

34
00:01:26,695 --> 00:01:30,356
IDamageable インターフェイスは generic 型の T を持ちます

35
00:01:30,356 --> 00:01:32,356
これはつまりこのインターフェイスでは generic 型を

36
00:01:32,356 --> 00:01:33,818
持てるということです

37
00:01:33,818 --> 00:01:35,818
IDamageable 内の関数

38
00:01:35,818 --> 00:01:38,984
Damage はパラメーターとして型 T を取ります

39
00:01:39,484 --> 00:01:41,484
クラスにより generic 型を持つ

40
00:01:41,484 --> 00:01:43,484
インターフェイスが実装されている場合は

41
00:01:43,484 --> 00:01:45,484
型を選択する必要があります

42
00:01:45,484 --> 00:01:48,701
そしてそこで選択された型は使用され続けねばなりません

43
00:01:49,611 --> 00:01:51,611
インターフェイスの実装には

44
00:01:51,611 --> 00:01:53,486
いくつかの要件とそれに伴う利点が存在します

45
00:01:53,486 --> 00:01:56,595
まずインターフェイスを実装するにはクラスが

46
00:01:56,595 --> 00:01:58,595
インターフェイスに存在する

47
00:01:58,595 --> 00:02:00,595
すべてのメソッド・プロパティ・イベント・インデクサーを 

48
00:02:00,595 --> 00:02:02,843
 public に宣言する必要があります

49
00:02:02,843 --> 00:02:05,729
これが行われていない場合はエラーが返されます

50
00:02:05,729 --> 00:02:07,729
インターフェイスの主な利点は

51
00:02:07,729 --> 00:02:10,160
複数のクラス間で一般的な機能を

52
00:02:10,160 --> 00:02:12,577
定義できる点にあります

53
00:02:12,577 --> 00:02:14,577
このため実装されるインターフェイスから

54
00:02:14,577 --> 00:02:16,577
各クラスで行えることを

55
00:02:16,577 --> 00:02:18,577
比較的確実に推測できるわけです

56
00:02:19,077 --> 00:02:21,077
インターフェイスを実装するにはクラスの持つ

57
00:02:21,077 --> 00:02:23,818
継承の後ろにカンマを付けて

58
00:02:23,818 --> 00:02:25,818
その後ろにインターフェイス名を入力します

59
00:02:25,818 --> 00:02:27,818
クラスが継承を持たない場合は

60
00:02:27,818 --> 00:02:29,280
カンマは不要です

61
00:02:29,280 --> 00:02:31,280
インターフェイスが generic 型を持つ場合は

62
00:02:31,280 --> 00:02:33,280
名前が 山カッコで囲まれて

63
00:02:33,280 --> 00:02:35,210
型とともに入力されます

64
00:02:35,210 --> 00:02:38,020
さて今から見ていくケースではクラス Avatar があり

65
00:02:38,020 --> 00:02:40,020
これは MonoBehaviour を継承します

66
00:02:40,020 --> 00:02:43,600
そして IKillable と IDamageable を実装し

67
00:02:43,600 --> 00:02:45,475
型は Float とします

68
00:02:45,475 --> 00:02:47,475
そしてインターフェイスで求められる両方の

69
00:02:47,475 --> 00:02:49,213
関数を宣言する必要があります

70
00:02:49,213 --> 00:02:51,213
ここで関数の本文部分は

71
00:02:51,213 --> 00:02:53,213
インターフェイスとは独立しているので

72
00:02:53,213 --> 00:02:55,213
好きなように実装することができます

73
00:02:55,213 --> 00:02:57,213
この種のインターフェイスはたとえば製作中のゲームで

74
00:02:57,213 --> 00:02:59,213
一気にダメージを与えたり

75
00:02:59,213 --> 00:03:01,654
まとめて殺したりする場合に便利に扱えます

76
00:03:01,654 --> 00:03:03,654
ただ実装された内容を見ていき

77
00:03:03,654 --> 00:03:06,150
この場合は IKillable と IDamageable を

78
00:03:06,150 --> 00:03:07,499
見ていけば ダメージやキルの中身も

79
00:03:07,499 --> 00:03:09,499
すぐに見て取れるでしょう

80
00:03:10,220 --> 00:03:12,054
ではなぜクラスにインターフェイスを

81
00:03:12,054 --> 00:03:14,054
実装するのでしょう?

82
00:03:14,054 --> 00:03:16,054
関数をクラスの中に書いてそれを

83
00:03:16,054 --> 00:03:18,499
他のクラスでは継承すればいいのでは?

84
00:03:18,499 --> 00:03:20,499
これに対する簡潔な答えは

85
00:03:20,499 --> 00:03:22,982
複数のインターフェイスを実装することはできても

86
00:03:22,982 --> 00:03:25,537
複数のクラスを継承することはできないということです

87
00:03:25,537 --> 00:03:27,537
このため広範にわたる機能を提供するときに

88
00:03:27,537 --> 00:03:29,537
インターフェイスを使うわけです

89
00:03:29,537 --> 00:03:31,537
もう少しきちんとした回答をすると インターフェイスは

90
00:03:31,537 --> 00:03:33,537
無関係なさまざまなクラスで

91
00:03:33,537 --> 00:03:36,317
共通の機能を使えるよう定義されます

92
00:03:36,317 --> 00:03:39,822
Wall と Car というクラスがあったとしましょう

93
00:03:39,822 --> 00:03:41,822
当然 Wall と Car にはほとんど共通点がありません

94
00:03:41,822 --> 00:03:44,408
ただしどちらも damageable（破損可能）ではあります

95
00:03:44,408 --> 00:03:46,701
このように全然中身の違うものに

96
00:03:46,701 --> 00:03:49,433
親クラスから継承させるのはあまりよい手ではありません

97
00:03:50,030 --> 00:03:52,818
こういった場合にインターフェイスを実装するのは役に立つのです
